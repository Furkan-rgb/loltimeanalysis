<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LoL Ranked History Viewer</title>
    <style>
      /* Light theme (default) */
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        line-height: 1.6;
        background-color: #f0f2f5;
        color: #1c1e21;
        padding: 2em;
        max-width: 800px;
        margin: 0 auto;
        transition: background-color 0.3s ease, color 0.3s ease;
      }
      .container {
        background-color: #fff;
        padding: 2rem;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        transition: background-color 0.3s ease, box-shadow 0.3s ease;
      }
      h1,
      h3 {
        color: #333;
        transition: color 0.3s ease;
      }

      /* Dark theme */
      @media (prefers-color-scheme: dark) {
        body {
          background-color: #18191a;
          color: #e4e6ea;
        }
        .container {
          background-color: #242526;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        h1,
        h3 {
          color: #e4e6ea;
        }
      }
      #controls {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
        margin-bottom: 1em;
      }
      input[type="text"],
      input[type="number"] {
        padding: 10px;
        border: 1px solid #ccc;
        border-radius: 6px;
        font-size: 1rem;
        background-color: #fff;
        color: #1c1e21;
        transition: background-color 0.3s ease, color 0.3s ease,
          border-color 0.3s ease;
      }

      @media (prefers-color-scheme: dark) {
        input[type="text"],
        input[type="number"] {
          background-color: #3a3b3c;
          color: #e4e6ea;
          border-color: #5a5b5c;
        }
        input[type="text"]:focus,
        input[type="number"]:focus {
          border-color: #0084ff;
          outline: none;
        }
      }
      #fetchButton {
        padding: 10px 20px;
        border: none;
        border-radius: 6px;
        background-color: #007bff;
        color: white;
        font-size: 1rem;
        cursor: pointer;
        transition: background-color 0.2s;
        min-width: 120px; /* Give button a consistent width */
        text-align: center;
        position: relative;
        overflow: hidden;
      }
      #fetchButton:disabled {
        background-color: #a9a9a9;
        cursor: not-allowed;
      }
      #fetchButton:hover:not(:disabled) {
        background-color: #0056b3;
      }

      /* Progress button styles */
      #fetchButton.progress-mode {
        background-color: #6c757d; /* Base gray background */
        color: white;
      }

      #fetchButton.progress-mode::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        width: var(--progress, 0%);
        background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 1;
      }

      #fetchButton.progress-mode span {
        position: relative;
        z-index: 2;
      }

      #fetchButton.progress-mode:disabled {
        background-color: #6c757d;
        cursor: not-allowed;
      }
      #logs {
        background-color: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        padding: 10px;
        max-height: 200px;
        overflow-y: auto;
        margin-bottom: 1em;
        font-family: monospace;
        transition: background-color 0.3s ease, border-color 0.3s ease;
      }

      @media (prefers-color-scheme: dark) {
        #logs {
          background-color: #3a3b3c;
          border-color: #5a5b5c;
          color: #e4e6ea;
        }
      }
      #results-container table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 1em;
      }
      #results-container th,
      #results-container td {
        padding: 12px;
        text-align: left;
        border-bottom: 1px solid #dee2e6;
        transition: border-color 0.3s ease;
      }
      #results-container th {
        background-color: #f8f9fa;
        transition: background-color 0.3s ease;
      }

      @media (prefers-color-scheme: dark) {
        #results-container th,
        #results-container td {
          border-bottom-color: #5a5b5c;
        }
        #results-container th {
          background-color: #3a3b3c;
        }
      }
      #error-message {
        color: #dc3545;
        min-height: 1.2em;
        font-weight: bold;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Fetch LoL Ranked History</h1>

      <div id="controls">
        <input
          type="text"
          id="gameName"
          placeholder="Game Name (e.g., Faker)"
        />
        <span>#</span>
        <input type="text" id="tagLine" placeholder="Tag (e.g., KR1)" />
        <button id="fetchButton">Fetch History</button>
      </div>
      <p id="error-message"></p>

      <h3>Logs:</h3>
      <div id="logs"></div>

      <h3>Match History:</h3>
      <div id="results-container">Data will appear here once fetched.</div>
    </div>

    <script>
      // --- DOM ELEMENT SELECTION ---
      const fetchButton = document.getElementById("fetchButton");
      const gameNameInput = document.getElementById("gameName");
      const tagLineInput = document.getElementById("tagLine");
      const logsDiv = document.getElementById("logs");
      const resultsContainer = document.getElementById("results-container");
      const errorMessageP = document.getElementById("error-message");

      // --- STATE MANAGEMENT ---
      const appState = {
        isDataLoaded: false,
        cooldownInterval: null,
        eventSource: null, // Replaces pollingInterval for SSE
      };

      // --- UI HELPER FUNCTIONS ---
      function validateInputs() {
        const gameName = gameNameInput.value.trim();
        const tagLine = tagLineInput.value.trim();
        const hasInputs = gameName && tagLine;
        if (!hasInputs) {
          errorMessageP.textContent =
            "Please enter both a Game Name and a Tag Line.";
        } else {
          errorMessageP.textContent = "";
        }
        const isInCooldownOrProcessing = fetchButton.disabled && !hasInputs;
        if (!isInCooldownOrProcessing) {
          fetchButton.disabled = !hasInputs;
        }
        return hasInputs;
      }

      function closeEventStream() {
        if (appState.eventSource) {
          appState.eventSource.close();
          appState.eventSource = null;
        }
      }

      function stopCooldown() {
        if (appState.cooldownInterval) {
          clearInterval(appState.cooldownInterval);
          appState.cooldownInterval = null;
        }
      }

      function setButtonState(state, duration = 0) {
        stopCooldown();
        fetchButton.disabled = false;
        fetchButton.classList.remove("progress-mode");

        switch (state) {
          case "IDLE_NO_DATA":
            fetchButton.innerHTML = "Fetch History";
            break;
          case "IDLE_WITH_DATA":
            fetchButton.innerHTML = "Update";
            break;
          case "POLLING": // Name kept for consistency, now means "streaming"
            fetchButton.innerHTML = "<span>Fetching...</span>";
            fetchButton.disabled = true;
            fetchButton.classList.add("progress-mode");
            fetchButton.style.setProperty("--progress", "0%");
            break;
          case "UPDATING":
            fetchButton.innerHTML = "<span>Updating...</span>";
            fetchButton.disabled = true;
            fetchButton.classList.add("progress-mode");
            fetchButton.style.setProperty("--progress", "0%");
            break;
          case "COOLDOWN":
            let timer = duration;
            fetchButton.disabled = true;
            fetchButton.innerHTML = `Cooldown (${timer}s)`;
            appState.cooldownInterval = setInterval(() => {
              timer--;
              if (timer <= 0) {
                stopCooldown();
                setButtonState(
                  appState.isDataLoaded ? "IDLE_WITH_DATA" : "IDLE_NO_DATA"
                );
              } else {
                fetchButton.innerHTML = `Cooldown (${timer}s)`;
              }
            }, 1000);
            break;
        }
        validateInputs();
      }

      function updateProgress(processed = 0, total = 100) {
        const percentage =
          total > 0 ? Math.round((processed / total) * 100) : 0;

        // Update button progress
        if (fetchButton.classList.contains("progress-mode")) {
          fetchButton.style.setProperty("--progress", `${percentage}%`);
          // Button text remains static - no percentage updates
        }
      }

      function renderResultsAsTable(data) {
        if (!data || data.length === 0) {
          resultsContainer.innerHTML =
            "<p>No recent ranked match data found.</p>";
          return;
        }
        let tableHTML = `<table><thead><tr><th>Date</th><th>Time</th><th>Champion</th><th>Outcome</th><th>Role</th><th>Match ID</th></tr></thead><tbody>`;
        for (const game of data) {
          // Convert timestamp to readable date and time
          const date = new Date(game.timestamp);
          const dateStr = date.toLocaleDateString();
          const timeStr = date.toLocaleTimeString([], {
            hour: "2-digit",
            minute: "2-digit",
          });

          const outcomeStyle =
            game.outcome === "Win" ? "color: #28a745;" : "color: #dc3545;";
          tableHTML += `<tr><td>${dateStr}</td><td>${timeStr}</td><td>${
            game.champion
          }</td><td style="${outcomeStyle}">${game.outcome}</td><td>${
            game.role || "N/A"
          }</td><td style="font-family: monospace; font-size: 0.8em;">${
            game.match_id
          }</td></tr>`;
        }
        tableHTML += "</tbody></table>";
        resultsContainer.innerHTML = tableHTML;
      }

      function resetUIForNewPlayer() {
        closeEventStream();
        stopCooldown();
        appState.isDataLoaded = false;
        resultsContainer.innerHTML = "Data will appear here once fetched.";
        logsDiv.innerHTML = "";
        updateProgress(0, 100);
        errorMessageP.textContent = "";
        setButtonState("IDLE_NO_DATA");
      }

      // --- REFACTORED API LOGIC FOR SSE ---

      async function fetchAndRenderHistory() {
        if (!validateInputs()) return false;
        const gameName = gameNameInput.value.trim();
        const tagLine = tagLineInput.value.trim();
        const url = `http://localhost:8000/history/${encodeURIComponent(
          gameName
        )}/${encodeURIComponent(tagLine)}`;

        try {
          const response = await fetch(url);
          if (response.status === 404) {
            logsDiv.innerHTML =
              "<div>No cached data found. Ready to fetch.</div>";
            setButtonState("IDLE_NO_DATA");
            return false;
          }
          if (!response.ok)
            throw new Error(`HTTP error! Status: ${response.status}`);

          const result = await response.json();
          logsDiv.innerHTML =
            "<div>Successfully displayed data from cache.</div>";
          renderResultsAsTable(result.data);
          appState.isDataLoaded = true;
          setButtonState("IDLE_WITH_DATA");
          return true;
        } catch (error) {
          errorMessageP.textContent =
            "Failed to fetch history. Server may be down.";
          console.error("Fetch history error:", error);
          setButtonState("IDLE_NO_DATA");
          return false;
        }
      }

      async function triggerUpdate() {
        if (!validateInputs()) return;
        const gameName = gameNameInput.value.trim();
        const tagLine = tagLineInput.value.trim();
        const url = `http://localhost:8000/update/${encodeURIComponent(
          gameName
        )}/${encodeURIComponent(tagLine)}`;

        try {
          const response = await fetch(url, { method: "POST" });
          if (response.status === 429) {
            const errorDetail = await response.json();
            const cooldownMatch = errorDetail.detail.match(/(\d+)/);
            if (cooldownMatch)
              setButtonState("COOLDOWN", parseInt(cooldownMatch[1], 10));
            return;
          }
          if (!response.ok)
            throw new Error(`HTTP error! Status: ${response.status}`);

          const result = await response.json();
          if (result.status === "started" || result.status === "in_progress") {
            connectToEventStream(); // Start listening for SSE updates
          }
        } catch (error) {
          errorMessageP.textContent =
            "Failed to trigger update. Check server connection.";
          console.error("Trigger update error:", error);
          setButtonState(
            appState.isDataLoaded ? "IDLE_WITH_DATA" : "IDLE_NO_DATA"
          );
        }
      }

      function connectToEventStream() {
        closeEventStream(); // Ensure any old connection is closed
        const gameName = gameNameInput.value.trim();
        const tagLine = tagLineInput.value.trim();
        const url = `http://localhost:8000/stream-status/${encodeURIComponent(
          gameName
        )}/${encodeURIComponent(tagLine)}`;

        appState.eventSource = new EventSource(url);
        const state = appState.isDataLoaded ? "UPDATING" : "POLLING";
        setButtonState(state);
        updateProgress(0, 100);
        logsDiv.innerHTML =
          "<div>Connection opened. Waiting for updates...</div>";

        appState.eventSource.onmessage = (event) => {
          const statusData = JSON.parse(event.data);

          if (statusData.status === "progress") {
            logsDiv.innerHTML = `<div>Processing...</div>`;
            updateProgress(statusData.processed, statusData.total);
          } else if (statusData.status === "ready") {
            closeEventStream();
            updateProgress(100, 100);
            logsDiv.innerHTML =
              "<div>Update complete! Fetching final data...</div>";
            setTimeout(fetchAndRenderHistory, 500);
          } else if (statusData.status === "idle_no_data") {
            // This means an update was triggered but found no new games
            closeEventStream();
            logsDiv.innerHTML = "<div>No new games found.</div>";
            setButtonState(
              appState.isDataLoaded ? "IDLE_WITH_DATA" : "IDLE_NO_DATA"
            );
          }
        };

        appState.eventSource.onerror = (error) => {
          console.error("EventSource failed:", error);
          closeEventStream();
          errorMessageP.textContent =
            "Connection to status stream lost. Please try again.";
          setButtonState(
            appState.isDataLoaded ? "IDLE_WITH_DATA" : "IDLE_NO_DATA"
          );
        };
      }

      async function initializePlayerState() {
        if (!validateInputs()) return;
        // First, display whatever is in the cache immediately
        await fetchAndRenderHistory();

        // Then, open a stream to check for an ongoing update
        const gameName = gameNameInput.value.trim();
        const tagLine = tagLineInput.value.trim();
        const url = `http://localhost:8000/stream-status/${encodeURIComponent(
          gameName
        )}/${encodeURIComponent(tagLine)}`;

        const initialStream = new EventSource(url);

        initialStream.onmessage = (event) => {
          const statusData = JSON.parse(event.data);
          // If the first thing we hear is "progress", it means a job was already running.
          // We connect our main event source to it.
          if (statusData.status === "progress") {
            logsDiv.innerHTML =
              "<div>Found an update already in progress!</div>";
            connectToEventStream();
          }
          // In any other case (ready, idle_no_data), the job is not running, so we just close.
          initialStream.close();
        };

        initialStream.onerror = (error) => {
          // It's normal for this to fail if the server is just starting, so don't show a big error.
          console.log(
            "Initial status check complete or failed, no active job found."
          );
          initialStream.close();
        };
      }

      // --- MAIN EVENT LISTENERS & INITIALIZATION ---
      fetchButton.addEventListener("click", async () => {
        if (!validateInputs()) return;

        // If data is already loaded, the button is for "Update"
        if (appState.isDataLoaded) {
          triggerUpdate();
        } else {
          // If no data is loaded, first try to fetch from cache.
          const hasCache = await fetchAndRenderHistory();
          // Only if there's no cache, trigger a new update.
          if (!hasCache) {
            triggerUpdate();
          }
        }
      });

      document.addEventListener("DOMContentLoaded", () => {
        gameNameInput.value = localStorage.getItem("lastGameName") || "";
        tagLineInput.value = localStorage.getItem("lastTagLine") || "";
        initializePlayerState(); // Check for cached data and ongoing jobs on load
      });

      function handleInputChange() {
        resetUIForNewPlayer();
        validateInputs();
      }
      gameNameInput.addEventListener("input", handleInputChange);
      tagLineInput.addEventListener("input", handleInputChange);
    </script>
  </body>
</html>
